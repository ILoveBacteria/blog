[{"content":"چی شده بود؟ داشتم یکی از مسائل Leetcode رو با گو حل می‌کردم که بعد از ارسال کردن کد و Accept شدنش، تصمیم گرفتم یکم کدم رو بهینه‌تر کنم.\nمن همیشه عادت داشتم مسئله‌های الگوریتمی رو با پایتون حل کنم ولی از موقعی که شروع کردم به یاد گرفتن گو، از گو استفاده می‌کنم و همین سطح پایین‌تر بودن گو باعث شده به بهینه‌ بودن بیشتر فکر کنم.\nکد غیر بهینه کدی که برای این مسئله زده بودم رو این پایین می‌بینید. از دیدنش وحشت نکنید 😊 اگر گو بلد نیستید یا کد خیلی طولانیه، قرار نیست بفهمید چیه. صرفا همین رو در نظر داشته باشید که چند حلقه for تو در تو داره که در هر پیمایش یک Hash-map رو دوباره می‌سازه و زباله روب1 عزیز بابد زحمت بکشه Hash-map قبلی رو پاک بکنه.\nهمونطور که مشخصه متغیری به اسم seen داریم که چند بار در حال از بین رفتن و ساخته شدن است.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 func isValidSudoku(board [][]byte) bool { for _, row := range board { seen := map[byte]struct{}{} for _, column := range row { if column == \u0026#39;.\u0026#39; { continue } if _, ok := seen[column]; ok { return false } seen[column] = struct{}{} } } for column := 0; column \u0026lt; 9; column++ { seen := map[byte]struct{}{} for _, row := range board { if row[column] == \u0026#39;.\u0026#39; { continue } if _, ok := seen[row[column]]; ok { return false } seen[row[column]] = struct{}{} } } for i := 0; i \u0026lt; 9; i += 3 { for j := 0; j \u0026lt; 9; j += 3 { seen := map[byte]struct{}{} for k := i; k \u0026lt; i+3; k++ { for l := j; l \u0026lt; j+3; l++ { if board[k][l] == \u0026#39;.\u0026#39; { continue } if _, ok := seen[board[k][l]]; ok { return false } seen[board[k][l]] = struct{}{} } } } } return true } کد بهینه در هر پیمایش حلقه نیاز به یک Hash-map خالی بود که به همین خاطر من اومده بودم هر بار یک Hash-map جدید می‌ساختم. حالا کاری که انجام دادم این بود که فقط یک بار اون هم در ابتدای کد این Hash-map رو می‌ساختم و هر بار که نیاز به یک Hash-map خالی داشتم همون رو clear می‌کردم.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 func isValidSudoku(board [][]byte) bool { +\tseen := map[byte]struct{}{} for _, row := range board { +\tclear(seen) -\tseen := map[byte]struct{}{} for _, column := range row { if column == \u0026#39;.\u0026#39; { continue } if _, ok := seen[column]; ok { return false } seen[column] = struct{}{} } } for column := 0; column \u0026lt; 9; column++ { +\tclear(seen) -\tseen := map[byte]struct{}{} for _, row := range board { if row[column] == \u0026#39;.\u0026#39; { continue } if _, ok := seen[row[column]]; ok { return false } seen[row[column]] = struct{}{} } } for i := 0; i \u0026lt; 9; i += 3 { for j := 0; j \u0026lt; 9; j += 3 { +\tclear(seen) -\tseen := map[byte]struct{}{} for k := i; k \u0026lt; i+3; k++ { for l := j; l \u0026lt; j+3; l++ { if board[k][l] == \u0026#39;.\u0026#39; { continue } if _, ok := seen[board[k][l]]; ok { return false } seen[board[k][l]] = struct{}{} } } } } return true } همین تغییر ریز باعث شد عملکرد کد تغییر محسوسی بکنه:\nپس حواسمون به سیستم-کال‌هایی که بیهوده در روند اجرایی کد وقفه ایجاد می‌کنند باشه.\nGarbage Collector\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2024-06-30T15:30:00Z","image":"https://blog.moeinarabi.ir/p/allocate-deallocate-optimization/cover_hu64b42dbdfbcc0730f0993cc09c40d428_22452_120x120_fill_box_smart1_3.png","permalink":"https://blog.moeinarabi.ir/p/allocate-deallocate-optimization/","title":"تاثیر Allocate و Deallocate کردن‌های بیهوده بر زمان اجرایی"},{"content":"سلام دنیا\n","date":"2024-06-27T00:00:00Z","image":"https://blog.moeinarabi.ir/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.moeinarabi.ir/p/hello-world/","title":"سلام دنیا"},{"content":"مقدمه احتمالا توی گشت و گذارتون در وب، این لوگوی خوشگل فایل Markdown رو دیدید! یا با فایل‌هایی رو به رو شدید که پسوند md. داشتن. اینجا می‌خوام یکم درباره‌ی کاربرد Markdown و سینتکس نوشتنش حرف بزنم.\nچرا از Markdown استفاده کنیم؟ شاید براتون عجیب بیاد که چرا باید به خودمون زحمت بدیم تا همچین متنی رو بنویسیم؛ چرا از ادیتورهایی مثل Microsoft Word استفاده نکنیم تا تنها با چند کلیک ساده یه عبارت رو bold کنیم؟\nاینجا چندتا علت رو بررسی می‌کنیم تا به تفاوت‌هاشون پی ببریم:\nمتن Markdown می‌تونه توی هر چیزی استفاده بشه. مثل سایت‌ها، مستندات، کتاب‌ها، ایمیل‌ها و خیلی چیزای دیگه. از این جهت کاربرد گسترده‌تری داره\nمتن Markdown وابسته به پلتفرم نیست. شما می‌تونید Markdown رو در وب یا روی هر دستگاهی با هر سیستم عاملی باز کنید و بخونید. ولی مثلا تجربه منتقل کردن یک فایل Word رو روی دستگاه دیگه‌ای حتما داشتین؛ فونت بهم می‌ریزه، جمله‌ها می‌پرن.\nادیتورهای متنی مثل word دیتا رو به شکل باینری ذخیره می‌کنند و تنها با خود همون ادیتور اجرا میشه ولی اگر یک فایل Markdown داشته باشین به راحتی میشه حتی توی محیط ترمینال بخونیم و تغییر بدیم.\nوب‌سایت‌هایی مثل GitHub به شکل ویژه‌ای از Markdown پشتیبانی می‌کنن. مثلا اگر با گیت‌هاب کار کرده باشید برای معرفی مخزن خود، فایلی با فرمت Markdown قرار می‌دین.\nسینتکس نوشتاری Markdown چندتا از سینتکس‌های ساده رو بررسی می‌کنیم:\nتیتر 1 2 3 4 5 6 # Heading level 1 ## Heading level 2 ### Heading level 3 #### Heading level 4 ##### Heading level 5 ###### Heading level 6 نتیجه:\nHeading level 1 Heading level 2 Heading level 3 Heading level 4 Heading level 5 Heading level 6 ضخیم 1 **Bold Text** Bold Text\nمورب 1 _Italic Text_ Italic Text\nضخیم و مورب 1 **_Bold and Italic text_** Bold and Italic text\nلینک 1 [Google](https://www.google.com) Google\nجدول 1 2 3 4 |name|age| |---|---| |moein|21| |ali|20| name age moein 21 ali 20 ","date":"2024-06-22T00:00:00Z","image":"https://blog.moeinarabi.ir/p/markdown/cover_hu388ca03af18dbd22abb7d18d32726fbd_3986_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://blog.moeinarabi.ir/p/markdown/","title":"چگونه یک متن Markdown بنویسیم؟"},{"content":"مقدمه چند روز پیش به یه ویدیو با عنوان با حال \u0026ldquo;از git pull هیچ وقت استفاده نکن\u0026rdquo; بر خوردم. با خودم گفتم مگه چه مشکلی می‌تونه داشته باشه؟\nداستان از چه قراره؟ داستان از این قراره که همه ما وقتی میخوایم آخرین تغییرات یه رپو رو از جایی مثل گیتهاب دریافت کنیم، از دستور git pull استفاده می‌کنیم. این دستور در اصل دوتا دستور در دل یک دستوره. در اصل وقتی ما دستور git pull رو اجرا می‌کنیم، اون پشت اول دستور git fetch اجرا میشه که میاد برنچ ریموتی به اسم \u0026lt;origin\u0026gt;/\u0026lt;branch_name\u0026gt; رو توی سیستم لوکالمون آپدیت می‌کنه و بعد با دستور git merge این برنچ رو روی برنچ اصلی با نام \u0026lt;branch_name\u0026gt; مرج می‌کنه.\nداستان اصلی از اینجا شروع میشه که یک مرج در حال اتفاق افتادنه. حالا اگر یه هم‌تیمی داشته باشیم که روی همون برنچ کامیت زده باشه، اون وقته که اتفاق خوبی نمی‌افته.\nمثلا در تصویر بالا، ما یه هم‌گروهی به اسم John داریم که هر دومون از کامیت A شروع به کار کردیم. John زودتر از ما کار خودش رو انجام داده، کامیت C رو اعمال کرده و تغییرات رو پوش کرده. حالا اگر ما بخوایم تغییرات خودمون رو پوش کنیم، گیت ارور میده و از ما می‌خواد که قبلش pull انجام بدیم. اگر توی چنین شرایطی pull انجام بدیم، حتی اگر هم کانفلیکتی رخ نده، دو برنچ لوکال و ریموت مرج میشن. مثل عکس پایین:\nیعنی یک کامیت اضافه‌تر!\nحالا همین رو تصور کنید ولی با تعداد رخداد بیشتر. برنچ ما پر میشه از کامیت‌های الکی و اضافی که گراف کامیت‌ها رو کثیف می‌کنه:\nنکته اینجاست که کانفلیکتی هم اگر نداشته باشیم، این اتفاق می‌افته. پس راه بهتر این جور موقع‌ها چیه؟\nراه بهتر به جای اینکه pull انجام بدیم و مرج اتفاق بیفته، rebase می‌کنیم. rebase کردن باعث میشه تغییرات برنچ ریموت پشت سر کامیت ما قرار بگیره:\n1 git pull --rebase حالا ممکنه سوال پیش بیاد اگر کانفلیکت داشتیم چطور؟\nناچارن از همون دستور git pull استفاده می‌کنیم تا resolve انجام بدیم و بعدش هم مرج.\n","date":"2024-05-28T00:00:00Z","image":"https://blog.moeinarabi.ir/p/why-git-pull-is-not-good/cover_hu614e4f2457196c15a855c81640c79a25_49096_120x120_fill_q75_box_smart1.jpg","permalink":"https://blog.moeinarabi.ir/p/why-git-pull-is-not-good/","title":"چرا git pull خوب نیست؟!"},{"content":"مقدمه فرض کنید به عنوان یک توسعه‌دهنده می‌خواهید پروژه خودتون رو برای استفاده کاربر منتشر کنید. آیا پروژتون رو با ده‌ها یا صدها کلاس نوشته شده در فولدرهای مختلف در اختیار کاربر قرار می‌دید؟ نه! اینجاست که باید با jar آشنا بشید. فایل jar یک فایل فشرده‌شده است که کلاس‌های جاوا، عکس، متن و\u0026hellip; به همراه فایل Manifest(در ادامه بهش می‌رسیم) را در خود جای می‌دهد و از فرمت‌های فشرده‌سازی مانند zip استفاده می‌کند.\nساختن فایل jar برای شروع اول مطمئن بشید که JDK روی سیستمتون نصب است. از این لینک می‌تونید نسخه مورد نظرتون رو دانلود کنید. برای ساخت فایل jar کافیست به فولدری که فایل‌ها و کلاس‌ها قرار گرفته‌اند برویم و با دستور زیر در محیط ترمینال فایل jar ساخته می‌شود:\nSyntax:\n1 jar -cf jarfilename inputfiles jarfilename: نام فایل خروجی inputfiles: نام فایل‌هایی است که قرار است فشرده شوند -c: یک فایل آرشیو خالی و جدید می‌سازد -f: مشخص می‌کند پس از آن، نام فایل خروجی به عنوان پارامتر دریافت شود مثال از ساخت فایل jar در اینجا ما با دو فایل JavaClass1.class و JavaClass2.class روبه‌رو هستیم و با دستور زیر یک فایل jar ساخته شده:\n1 jar -cvf export.jar *.class استفاده از v- فرایند فشرده‌سازی را در خروجی نمایش می‌دهد. اگر تعداد زیادی فایل کلاس را می‌خواهید در فایل jar قرار دهید می‌توانید از class.* استفاده کنید به جای اینکه تک تک نام فایل‌ها را بنویسید.\nمشاهده محتوای فایل jar پس از آنکه یک فایل jar بدست آمد، برای دیدن فایل‌های موجود در آن از دستور زیر استفاده می‌شود:\nSyntax:\n1 2 3 jar -tf jarfilename Example: jar -tf export.jar خروجی:\n1 2 3 4 META-INF/ META-INF/MANIFEST.MF JavaClass1.class JavaClass2.class یک فایل jar به طور پیش فرض دارای فایل Manifest می‌باشد و همیشه در فولدر META-INF قرار دارد.\nاستخراج کردن فایل jar برای extract کردن از دستور زیر استفاده می‌شود:\nSyntax:\n1 2 3 jar -xf jarfilename Example: jar -xf export.jar برای extract کردن حتی می‌توان از ابزارهایی که یک فایل zip را extract می‌کنند، استفاده کرد.\nآپدیت کردن فایل jar اگر پروژه‌ی ما یک پروژه‌ی حجیم و بزرگی باشد، پس از تغییراتی که در پروژه اعمال می‌کنیم، برای تبدیل آن به فایل جدید jar زمان طولانی‌ صرف می‌شود. در اینجا بهتر است به جای ساختن یک فایل جدید jar، فایل قبلی را آپدیت بکنیم. برای آپدیت کردن محتوای فایل از دستور زیر استفاده می‌کنیم:\nSyntax:\n1 jar -uf jar-file input-file(s) Example:\n1 java -uf export.jar *.class بعد از نوشتن نام فایل jar مورد نظر، فایل‌ها و کلاس‌هایی را که می‌خواهیم آپدیت بکنیم می‌نویسیم. این امکان باعث می‌شود تا به جای اینکه دوباره تمام فایل‌ها را فشرده بکنیم، فقط فایل‌هایی که تغییرات داشتنند را جایگزین فایل‌های قبلی در jar بکنیم.\nقابلیت اجرا شدن فایل jar پیش از آنکه یاد بگیریم چگونه یک فایل jar را اجرا کنیم، باید آن را برای اجرا شدن آماده‌سازی کنیم. فرض می‌کنیم در پروژه، کلاسی با نام Main.class ساخته‌ایم و در آن متد main را پیاده‌سازی کرده‌ایم. اکنون باید به فایل jar بفهمانیم که متد main در چه کلاسی قرار دارد تا هنگام اجرا شدن jar، آن را اجرا کند. با استفاده از دستور زیر هنگام ساخت فایل jar این امکان را اضافه می‌کنیم:\nSyntax:\n1 jar -cfe jarfilename mainclass import-files Example:\n1 jar -cfe export.jar Main client.class server.class logo.jpeg توجه کنید که کلاس Main بدون class. نوشته می‌شود. روش دیگری هم برای اضافه کردن Main وجود دارد که در ادامه در مبحت Manifest به آن می‌رسیم.\nاکنون می‌توان فایل jar خود را با دستور زیر اجرا کرد:\nSyntax:\n1 java -jar jarfilename Example:\n1 java -jar export.jar فایل Manifest زمانی که یک فایل jar ساخته می‌شود به صورت اتوماتیک در آن فایل Manifast هم ساخته می‌شود. حالا اصلا Manifast چی است؟\nهر فایل jar یک فایل Manifest دارد که جزئیات و اطلاعات آن در Manifest نوشته شده است. نام این فایل به صورت پیش فرض MANIFEST.MF نام‌گذاری شده و در فولدر META-INF قرار دارد. در تصویر بالا نمونه‌ای از این فایل آمده‌است؛ حتی می‌تواند شامل جزئیات بیشتری باشد. ورودی فایل Manifest از دو قسمت تشکیل شده است، نام و مقدار. نوشتن نام و مقدارهای Manifest چند نکته دارد که به آن می‌پردازیم: باید یک اسپیس پس از \u0026quot;:\u0026quot; و قبل از مقدار باشد. بعد از آخرین خط، یک خط باید خالی باشد. متن باید از انکودر UTF-8 استفاده کند. وقتی کلاس main را مشخص می‌کنیم نباید پسوند class. را پس از آن بنویسیم.\nآپدیت کردن فایل Manifest اگر فایل jar را ساخته‌ایم و می‌خواهیم تغییراتی روی فایل Manifest بدهیم؛ ابتدا یک فایل txt. می‌سازیم و سپس برای اعمال تغییرات از دستور زیر استفاده می‌کنیم:\nExample:\n1 jar -ufm export.jar manifest.txt شناساندن کلاس main از طریق Manifest در قسمت‌های بالاتر توضیح داده شد که چگونه هنگام ساخت یک فایل jar، کلاس main را برای اجرا شدن به آن اضافه کنیم. حال اگر فایل jar را قبلا ساخته باشیم و کلاس main را به آن اضافه نکرده باشیم، کافیست خط زیر را به فایل Manifest اضافه کنیم:\n1 Main-Class: Main حتما دقت کنید که class. پس از آن را نباید بنویسیم.\nاستفاده از IDE تا به این جا با jar و با انواع دستورهاش آشنا شدیم. اگر پروژه‌ی ما از کتابخانه‌های خارجی استفاده می‌کرد، قرار دادن این کتابخانه‌ها در فایل jar کمی پیچیده می‌شد. محیط‌های توسعه قابلیت‌های پیشرفته‌ای در اختیارمان قرار می‌دهند که کار را برای ما ساده‌تر می‌کنند. در این قسمت ساختن یک فایل jar را در IntelliJ بررسی می‌کنیم.\nابتدا از نوار بالا گزینه File را انتخاب می‌کنیم و به قسمت Artifacts می‌رویم. روی علامت + و سپس روی jar کلیک می‌کنیم. گزینه‌ی From modules with dependencies انتخاب می‌کنیم. در فیلدهای پیش رو می‌توان کلاس Main را انتخاب کرد. در انتها روی OK کلیک می‌کنیم. در صفحه اصلی نرم‌افزار از نوار بالا روی Build و سپس Build Artifacts کلیک می‌کنیم. فایل jar مورد نظر را انتخاب کنید تا فرایند ساخت فایل jar آغاز شود. فایل‌های jar به طور پیش فرض در مسیر out/artifacts قرار می‌گیرد.\nمنابع Working with JAR and Manifest files In Java - GeeksforGeeks Jar files in Java - GeeksforGeeks Compile and build applications with IntelliJ IDEA | IntelliJ IDEA JAR (file format) - Wikipedia ","date":"2022-03-01T00:00:00Z","image":"https://blog.moeinarabi.ir/p/jar-file/cover_hucaaf8615d09761f0c141372d56b9c48f_17684_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://blog.moeinarabi.ir/p/jar-file/","title":"ساختن و اجرا کردن فایل jar در زبان جاوا"}]